+++
date = "2015-01-12T12:00:00+09:00"
draft = false
title = "エラーは値"
+++

# エラーは値

Goプログラマ、特にまだGoに不慣れな開発者に共通する議論の話題といえば、エラー処理の方法でしょう。
議論が次のようなコードの連続になることを嘆く結論に至ることがしばしばあります。

```
if err != nil {
    return err
}
```

先日、確認できるすべてのオープンソースプロジェクトをスキャンしてみたところ、このスニペットは
先のような開発者が信じているほどではなく、せいぜい1ページに1つか2つ現れる程度であることがわかりました。
それでもなお、いつも次のイディオムをタイプしなければいけないと強く信じているのであれば、
それは何かが間違っていますし、明らかに問題の対象はGoそれ自信となってしまいます。

```
if err != nil
```

これは不幸なことですし、語弊があり、そして容易に訂正が可能なことです。
おそらく、そのように信じてしまっているような状況になったのは、信じているプログラマがGoを使い始めて
まだ日が浅く、「エラーをどう処理したらよいか」という問いに対して、このパターンを覚えて、
そこで止まってしまっているのだと思います。他の言語ではtry-catch節や他の同様のエラー処理機構を
使っているのでしょう。それゆえ、そのプログラマは、私が古い言語ではtry-catch節を使っていたような場合でも、
Goではただ `if err != nil` と打っていると考えているのでしょう。時間が経つにつれて、
Goではこのようなスニペットが蔓延しだし、その結果不格好になってしまいました。

この表現がしっくり来るかどうかはわかりませんが、こういったGoプログラマはエラーに関して根本的な点を
見失っています。 _エラーは値です。_

値はプログラムが可能で、エラーは値なので、エラーはプログラム可能なのです。

もちろん、エラー値がnilかどうかを検証する文はよくありますが、エラー値でできることは他にもたくさんあります。
そしてそれらをあなたのプログラムに適用することで、プログラムが改善され、丸暗記で使っているおきまりの形のif文を
排除することができます。

次のスニペットは `bufio` パッケージの [Scanner](http://golang.org/pkg/bufio/#Scanner) 型の簡単な例です。
Scanner型の [Scan](http://golang.org/pkg/bufio/#Scanner.Scan) メソッドは、Scannerの中にあるI/Oを処理し、
その中ではもちろんエラーが発生するでしょう。しかし `Scan` メソッドはエラーを一切公開しません。
代わりにbool値を返し、別のメソッドがスキャンが終わったあとに、エラーが発生したかを報告します。
クライアント側のコードは次のようになります。

```
scanner := bufio.NewScanner(input)
for scanner.Scan() {
    token := scanner.Text()
    // tokenの処理
}
if err := scanner.Err(); err != nil {
    // エラーの処理
}
```

たしかに、エラーがnilかどうかの確認はしていますが、その処理は一度しかしていません。 `Scan` メソッドは
代わりに次のように定義することもできたでしょう。

```
func (s *Scanner) Scan() (token []byte, error)
```

この場合はクライアント側のコードは次のようになるでしょう。（トークンの読み出し方に依存します）

```
scanner := bufio.NewScanner(input)
for {
    token, err := scanner.Scan()
    if err != nil {
        return err // あるいはbreak
    }
    // tokenの処理
}
```
さきほどと大きな違いはありませんが、唯一の重要な違いがあります。後者のコードでは、クライアントは
繰り返しの度にエラーの確認をしなければなりません。しかし実際の `Scanner` のAPIでは
エラー処理は、トークンを繰り返し取得する肝心なAPIの要素からは抽象化され切り離されています。
それゆえ、実際のAPIでは、クライアント側のコードはより自然な形になります。
トークンを取り出す処理が完了するまでループして、エラーのことは考えずにすみます。
エラー処理が一連のトークンの処理を分かりにくくすることはありません。

抽象化の下で、実際に何が起きているかですが、もちろん、 `Scan` がI/Oエラーに遭遇したら、
すぐさまそれを記録し、 `false` を返します。クライアントが別のメソッドである `Err` を呼び出したら、
そのエラーの値を返します。これは些細な事ではありますが、これは

```
if err != nil
```

をクライアントのコード内のあちこちに書いたり、トークンごとにエラーを確認することとは違います。
これがエラー値とプログラミングをするということです。単純なプログラミングですが、
それでもこれがプログラミングなのです。
