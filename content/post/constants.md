+++
date = "2014-08-25T14:49:44+09:00"
draft = false
title = "定数 (constants)"
+++

# 定数
[Constants](https://blog.golang.org/constants) by Rob Pike

## はじめに
Goは、数値型を混合して操作することを許さない静的型付け言語で。 `flaot64` を `int` に
足せませんし、さらに言えば `int32` を `int` を足すこともできません。しかし、 `1e6*time.Second` や
`math.Exp(1)` あるいは `1<<('\t'+2.0)` と書くことは許されています。Goでは、定数は変数と違って、
通常の数字と同様に振る舞います。この記事では、なぜそうなっているのか、そしてそれが何を意味するのかを
説明します。

## 背景: C言語

Go言語を考え始めた初期の頃、C言語やその系譜の言語が数値型をまぜこぜに使うことを許していることで起きている多くの問題について話しました。
多くの奇妙なバグ、クラッシュ、移植可能性の問題は、サイズと「符号有無」が異なる整数を混ぜている式によって起きています。
軽々の多いCプログラマにとっても、次の計算結果はわかるかもしれませんが、アプリオリには明らかではありません。

```
unsigned int u = 1e9;
long signed int i = -1;
... i + u ...
```

結果はどれくらいの大きさになるのでしょう。その値はなんでしょうか。符号は付いているのかいないのか。

見難いバグがここに潜んでいます。

C言語には「the usual arithmetic conversions」と呼ばれる規則があり、年月を経てその規則が変わってきたことがこの規則の儚さを示しています。
（これから昔から知られているもっと多くのバグを紹介します）

Goを設計するときに、数値型を混ぜてはいけないということをしっかりと決めることでこの地雷原を避ける事にしました。
`i` と `u` を足したい場合には、結果をどうしたいかを明示しなければいけません。次のように変数があったとして、

```
var u uint
var i int
```

`uint(i)+u` または `i+int(u)` のどちらかに書けます。これはどちらの書き方でも足し算の意味と型がはっきりと表現されていますが、
C言語の場合とは異なって `i+u` と書くことはできません。 `int` が32ビット型の場合でさえ、 `int` と `int32` を混ぜることすらできません。

この厳格さによって、よくありがちなバグや他の問題が取り除かれます。これはGoにおいて非常に重要な性質です。
しかしこの厳格さにはコストが掛かります。意味を自明にするために、ときにこの厳格さがプログラマに不格好な
型変換のコードを追加することを求めます。

では定数ではどうでしょうか。これまでに述べてきたことからすると、どうすれば規則を守ったまま `i = 0` または `u = 0` と書けるでしょうか。
`0` の型は何でしょうか。単純な状況、たとえば `i = int(0)` ような場面で、型変換を書かなければいけないのは筋がよくありません。

私たちはすぐに数値の定数を扱う場合には、他のC言語の類似言語での動作とは異なる振る舞いをさせれば良いと気が付きました。
多くの考察と実験の後に、ほぼ常に正しいと信じられ、つねにプログラマを定数の型変換から解放し、それでいてコンパイラに
警告されることなく `math.Sqrt(2)` のように書ける設計を思いつきました。

手短に言えば、Goの定数は、とにかくほとんど場合、うまく動きます。ではそれがどのようになっているか見てみましょう。

## 用語解説

まず、手短に定義します。Goでは `const` は `2` 、 `3.14159` 、 `"scrumptious"` といったスカラー値に対する名前を決める
キーワードです。このような値は、名前が付いているかにかぎらず、Goでは _定数_ と呼ばれます。定数は定数からなる式からも
生成することが出来ます。たとえば `2+3` 、 `2+3i` 、 `math.Pi/2` あるいは `("go"+"pher")` といったものがそれです。

定数がない言語もありますし、 `const` という単語に対してより汎用的な定義がある言語やより汎用的な用途がある言語もあります。
たとえばC言語はC++では、 `const` はより複雑な値のより複雑な性質を分類する型修飾子です。

しかしGoでは、定数はとても単純で、変化しない値のことを指します。以降はGoでの場合のみを話します。

## 文字列定数

数値の定数には多くの種類があります。たとえば整数、浮動小数点数、ルーン（訳注：Unicodeのコードポイントを表す整数値）、符号あり、符号なし、虚数、複素数などがあります。
まずはより単純な形式の定数である文字列定数から話を始めましょう。文字列定数は理解がしやすく、Goにおける定数の型の問題を調べるときにより小さな部分だけ考えればよくなります。

文字列定数はある文字列をダブルクォーテーションで囲ったものです。（Goにはraw文字列リテラルもあり、これはバッククォートで囲みます。ここの議論においては
両者ともに同様の性質があるため省きます。）ここに文字列定数があります。

```
"Hello, 世界"
```

（文字列の表現と解釈に関してより詳しい内容は[こちらのブログポスト](https://blog.golang.org/strings)を参照してください。）

この文字列定数はどんな型でしょうか。見たままで答えれば `string` ですが、それは _間違い_ です。

これは _型付けされていない文字列定数_ で、不変の文字列の値を持っているがまだ決まった型がないもの、といえるでしょう。
そうです、これは文字列なのですが、Goでの `string` 型の値ではないのです。型付けされていない文字列定数は、名前を与えた時にも
同様のままでいます。

```
const hello = "Hello, 世界"
```

この宣言のあと、 `hello` もまた型付けされていない文字列定数となります。型付けされていない定数はただの値で、
異なる型の値と結合する厳格な規則に従わなければならなくなる決められた型をまだ持っていない値となります。

この _型付けされていない_ 定数という考え方によって、Goで定数を自由度高く使うことができるのです。

それでは _型付けされた_ 文字列定数とはなんなのでしょう。それは次のように型を与えられた定数のことです。

```
const typedHello string = "Hello, 世界"
```

`typedHello` の宣言は、等号の前で `string` 型が明示されていることに注目してください。これは `typedHello` が
Goの `string` 型であることを意味していて、Goでの異なる型の変数に代入できないことを意味しています。
これは次のコードは動きますが、

```
var s string
s = typedHello
fmt.Println(s)
```

このコードは動かないということです。

```
type MyString string
var m MyString
m = typedHello // 型エラー
fmt.Println(m)
```

変数 `m` は `MyString` 型で、異なる型には値は代入できません。 `MyString` 型の値のみ代入できます。
たとえば次のコードを見てください。

```
const myStringHello MyString = "Hello, 世界"
m = myStringHello // OK
fmt.Println(m)
```

あるいは型変換をさせてもできるでしょう。

```
m = MyString(typedHello)
fmt.Println(m)
```

_型付けされていない_ 文字列定数の話に戻ると、型がないことによって、型付けされた変数に代入しても
型エラーが発生させないというのは役に立つ性質です。つまり、このようなコードや

```
m = "Hello, 世界"
```

あるいはこのように書けるのです。

```
m = hello
```

なぜなら、型付けされた定数の `typedHello` や `myStringHello` とは違って、型付けされていない定数の `"Hello, 世界"` や
`hello` には _型がないからです_ 。 `string` と互換性のあるどのような型の変数にもエラーなしで代入できます。

これらの型付けされていない文字列定数はもちろん文字列であるため、文字列を使って良い所でのみどこでも使えますが、
`string` という _型_ を持っていないのです。

## デフォルト型

Goのプログラマであるあなたは、まちがいなく次のような宣言を数多く見てきたことでしょう。

```
str := "Hello, 世界"
```

ここまでの説明を読んで、「もし定数が型付けされていないのであれば、どうやって `str` はこの変数宣言で型を得るのだろう」と疑問に思ったことでしょう。
その答えはというと、型付けされていない定数にはデフォルトの型、つまり型が与えられてなかった場合に必要なときに値に対して与える暗黙的な型を持っているということです。
型付けされていない文字列定数であれば、デフォルト型は明らかに `string` なので、

```
str := "Hello, 世界"
```

や

```
var str = "Hello, 世界"
```

は次の宣言とまったく同じ意味になります。

```
var str string = "Hello, 世界"
```

型付けされていない定数について考える1つの方法としては、彼らは値の理想的な空間にいて、そこではGoの完全な型システムほど
制限がないと思えばいいでしょう。しかしその定数にたいして何かしたいと思ったら、それを変数に代入する必要があり、
変数に代入するときには（定数自身ではなく） _変数_ には型が必要で、その定数は変数に対して自分がどのような型であるべきか
伝えることができます。この例では `str` は `string` 型の値になります。なぜなら型付けされていない文字列定数は
そのデフォルト型である `string` であると宣言するからです。

このように変数宣言をした場合、その変数は型と初期値を含めて宣言されています。しかしながら、ときに定数を、その値の代入先が
不明瞭なときに使うことがあります。たとえば次の文を考えてみましょう。

```
fmt.Printf("%s", "Hello, 世界")
```

`fmt.Printf` のシグネチャは次のとおりです。

```
func Printf(format string, a ...interface{}) (n int, err error)
```

これは、この関数の（フォーマット文字列のあとの）引数がインターフェース値であることを意味しています。 `fmt.Printf` が
型付けされていない定数を使って呼び出された場合、インターフェース値が作られて引数に渡されます。そしてその引数に保存される
具象型はその定数のデフォルト型になります。このプロセスは先に型付けされていない文字列定数で初期値を宣言した状況に似ています。

この結果は次の例で確認できます。ここでは `fmt.Printf` で値を表示するのにフォーマット文字 `%v` を使い、値の型を表示するのに `%T` を使っています。

```
fmt.Printf("%T: %v\n", "Hello, 世界", "Hello, 世界")
fmt.Printf("%T: %v\n", hello, hello)
```

（訳注: 出力は次のとおりです。）

```
string: Hello, 世界
string: Hello, 世界
```

もし定数に型があれば、それがインターフェースに伝わり、次の例のようになります。

```
fmt.Printf("%T: %v\n", myStringHello, myStringHello)
```

（訳注: 出力は次のとおりです。）

```
main.MyString: Hello, 世界
```

（インターフェース値がどのように扱われるかをより詳しく知りたい場合は、次の
[ブログポスト](https://blog.golang.org/laws-of-reflection) の最初の節を参照してください。）

まとめとして、型付けされた定数はGoの型付けされた値のルールに従います。一方で、型付けされていない定数は
同じやり方でGoの型を決めるのではなく、より自由に型を混ぜたり一致させたりします。しかしながら、
あからさまなデフォルト型が、他の型情報が得られない場合、そしてその場合に限り適用されます。

## 構文から決定されるデフォルト型
型付けされていない定数のデフォルト型は構文により決定されます。文字列定数であれば、唯一取りうる
暗黙型は `string` です。 [数値定数](http://golang.org/ref/spec#Numeric_types) の場合は
暗黙型はより多くの種類を取り得ます。整数定数は `int` がデフォルト型ですし、浮動小数点数定数は
`float64` 、 ルーン定数は `rune` （ `int32` のエイリアス）、虚数定数は `complex128` がデフォルト型です。
ここで、この権威あるprint式でデフォルト型を実際に動かして確認しましょう。

```
fmt.Printf("%T %v\n", 0, 0)
fmt.Printf("%T %v\n", 0.0, 0.0)
fmt.Printf("%T %v\n", 'x', 'x')
fmt.Printf("%T %v\n", 0i, 0i)
```

（演習： `'x'` の場合の結果を説明しなさい。）

## 真偽値
型付けされていない文字列定数について話したことはすべて型付けされていない真偽値定数についてもあてはまります。
`true` と `false` はどのような真偽値の変数にも代入できる型付けされていない真偽値定数で、一度型が与えられると
混ぜることは出来ません。

```
type MyBool bool
const True = true
const TypedTrue bool = true
var mb MyBool
mb = true      // OK
mb = True      // OK
mb = TypedTrue // ダメ
fmt.Println(mb)
```

上の例を実行して何が起きるか見たあと、 "ダメ" とコメントされている行をコメントアウトして
再び実行してみましょう。ここにあるパターンはすべて文字列定数の場合の規則に従っています。

## 浮動小数点数
浮動小数点数定数は多くの場合真偽値定数と同様です。これまで何度か出している例は浮動小数点数の場合にも
適用できます。

```
type MyFloat64 float64
const Zero = 0.0
const TypedZero float64 = 0.0
var mf MyFloat64
mf = 0.0       // OK
mf = Zero      // OK
mf = TypedZero // ダメ
fmt.Println(mf)
```

ひとつこの例でうまくいかないことがあるとすればGoには _2つの_ 浮動小数点数があることです。
`float32` と `float64` です。型付けされていない浮動小数点数定数は `float32` に問題なく代入できますが、
そのデフォルト型は `float64` です。

```
var f32 float32
f32 = 0.0
f32 = Zero      // OK: Zeroは型付けされていない
f32 = TypedZero // ダメ: TypedZeroはfloat64でありfloat32ではない
fmt.Println(f32)
```

浮動小数点数値はオーバーフロー、つまり値の範囲という概念を紹介するのに良い題材です。

数値定数は任意精度の数値空間に存在しています。つまり、それらは単なる有限小数なのです。
しかし、それらがある変数に代入された場合には、その値が代入先に合うようにならなければいけません。
定数で非常に大きな値を宣言することが出来ます。

```
const Huge = 1e1000
```

これは単なる数字で、それ以外の何者でもありません。しかし、それを代入できませんし、表示することさえできません。
この式はコンパイルすら通りません。

```
fmt.Println(Huge)
```

エラーは「constant 1.00000e+1000 overflows float64 （定数 1.00000e+1000 は float64 の範囲からオーバーフローしています）」
というもので、これは正しい内容です。しかし、 `Huge` が使える時もあります。それは、他の定数との式の中で使って、
その式の結果が `float64` の範囲内に収まる場合です。次の式を見てください。

```
fmt.Println(Huge / 1e999)
```

これは `10` を出力します。予想通りです。

同様に、浮動小数点数定数には非常に高い精度を持たせることが出来るので、それが関わる数値計算はより正確になります。
[math](https://golang.org/pkg/math) パッケージで定義されている定数は `float64` で扱える範囲よりも
多くの桁数を持っています。これは `math.Pi` の定義です。

```
Pi    = 3.14159265358979323846264338327950288419716939937510582097494459
```

この値が変数に代入されたときに、精度がある程度失われます。代入することで元の高精度の値に最も近い
 `float64` （あるいは `float32` ）の値ができます。次のスニペットでは

```
pi := math.Pi
fmt.Println(pi)
```

`3.141592653589793` が出力されます。
