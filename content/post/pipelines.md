+++
date = "2014-03-13T08:19:15+09:00"
draft = true
title = "Goの並行パターン：パイプラインとキャンセル (Go Concurrency Patterns: Pipelines and cancellation)"
tags = ["concurrency", "pipeline", "cancellation"]
+++

# Goの並行パターン：パイプラインとキャンセル
[Go Concurrency Patterns: Pipelines and cancellation](https://blog.golang.org/pipelines) by Sameer Ajmani

## はじめに
Goの並行性に関する基本要素によって、I/Oや複数のCPIを効率的に使うことができるストリーミングデータパイプラインを
簡単に構築することができます。この記事ではそのようなパイプラインの例を紹介し、操作が失敗したときに発生する
繊細な事柄にハイライトを当て、また失敗に綺麗に対応するテクニックを紹介します。

## パイプラインとはなにか
Goにおいて、パイプラインの厳密な定義はありません。パイプラインは数ある並行プログラミングの種類の一つに過ぎません。
正式な定義ではないですが、パイプラインとはチャンネルによって接続された一連の _ステージ_ を挿します。
そこでは、各ステージでは同じ関数を実行するゴルーチンのまとまりになっています。
各ステージではゴルーチンは次の役割を果たします。

* _上流_ から _流入_ チャンネル経由で値を受け取る
* そのデータに対してある関数を実行し、通常は新しい値を生成する
* _下流_ へ _流出_ チャンネル経由で値を送信する

各ステージでは、任意の数の流入と流出のチャンネルを持っています。ただし最初と最後のステージは例外で、
それぞれ流出と流入のチャンネルのみが存在します。最初のステージは時々 _ソース_ あるいは _プロデューサー_ と呼ばれ、
最後のステージは _シンク_ あるいは _コンシューマー_ と呼ばれます。

パイプラインの考え方とそのテクニックを説明するために単純なパイプラインの例から始めてみましょう。
あとでより現実的な例を紹介します。

## 数字を平方する
3つのステージからなるパイプラインを考えてみましょう。

最初のステージ `gen` は整数のリストからチャンネルに変換する関数です。このチャンネルがリスト内の整数を出すことになります。
`gen` 関数は整数をチャンネルに送信するゴルーチンを起動し、すべての値が送信されたらチャンネルを閉じます。

```
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}
```

2番めのステージは `sq` で、チャンネルから整数を受信して、受信した整数それぞれの平方を出すチャンネルを返します。
流入のチャンネルが閉じて、すべての値を下流に送った後に、流出のチャンネルを閉じます。

```
func sq(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}
```

`main` 関数はパイプラインを設定し、最後のステージを実行します。2番めのステージから値を受信し、チャンネルが閉じるまで、
それぞれを出力します。

```
func main() {
    // パイプラインを設定する。
    c := gen(2, 3)
    out := sq(c)

    // 出力を消費する。
    fmt.Println(<-out) // 4
    fmt.Println(<-out) // 9
}
```

`sq` では流入と流出のチャンネルでそれぞれ同じ型なので、 `sq` を何回でも繰り返すことができます。
また `main` を他のステージと同様にrangeを使ったループに書き換えることもできます。

```
func main() {
    // パイプラインを設定して出力を消費する。
    for n := range sq(sq(gen(2, 3))) {
        fmt.Println(n) // 16 then 81
    }
}
```

## ファンアウト、ファンイン
チャンネルが閉じるまで複数の関数が1つのチャンネルを読み込むことが可能です。
これは _ファンアウト_ と呼ばれます。この構成はCPU使用率とI/Oを平行に使うために
ワーカー群に仕事を分配する方法を提供しています。

1つの関数は入力チャンネルを多重化して1つのチャンネルに流し込むことで、すべての入力が閉じるまで
複数の入力から読み込み処理をすることができて、流し込む先のチャンネルはすべての入力が閉じると閉じられます。
これを _ファンイン_ と呼びます。

先ほどのパイプラインを2つの `sq` のインスタンスを実行するように変更し、それぞれが同一の
入力チャンネルから読み込むようにできます。ここで新しい関数 `merge` を用意して結果をファンインします。

```
func main() {
    in := gen(2, 3)

    // sq の仕事を同一のチャンネル in から読み込む2つのゴルーチンに分配します。
    c1 := sq(in)
    c2 := sq(in)

    // c1 と c2 の結果をマージしたものを消費します。
    for n := range merge(c1, c2) {
        fmt.Println(n) // 4 then 9, or 9 then 4
    }
}
```

`merge` 関数は、流入チャンネルそれぞれに対してゴルーチンを起動して、値を唯一の流出チャンネルに
コピーすることで、チャンネルのリストを1つのチャンネルに変換します。すべての `output` ゴルーチンが
起動したら、 `merge` は更にもう一つゴルーチンを起動して、そのチャンネルへの送信がすべて終わったら
流出チャンネルを閉じます。

閉じたチャンネルに送信するとパニックになるので、closeを呼ぶ前にすべての値が送信されていることを
確実にすることが大事です。 [sync.WaitGroup](http://golang.org/pkg/sync/#WaitGroup) 型はこのような
同期を用意する簡単な方法を提供しています。

```
func merge(cs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    // cs 内の各入力チャンネルに対して output ゴルーチンを起動。
    // output は c が閉じるまで c から out に値をコピーして、その後 wg.Done を呼び出す。
    output := func(c <-chan int) {
        for n := range c {
            out <- n
        }
        wg.Done()
    }
    wg.Add(len(cs))
    for _, c := range cs {
        go output(c)
    }

    // output ゴルーチンがすべて終了したら out を閉じるためのゴルーチンを起動する。
    // これは wg.Add が呼び出された後に起動しなければならない。
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}
```
