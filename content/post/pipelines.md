+++
date = "2014-03-13T08:19:15+09:00"
draft = true
title = "Goの並行パターン：パイプラインとキャンセル (Go Concurrency Patterns: Pipelines and cancellation)"
tags = ["concurrency", "pipeline", "cancellation"]
+++

# Goの並行パターン：パイプラインとキャンセル
[Go Concurrency Patterns: Pipelines and cancellation](https://blog.golang.org/pipelines) by Sameer Ajmani

## はじめに
Goの並行性に関する基本要素によって、I/Oや複数のCPIを効率的に使うことができるストリーミングデータパイプラインを
簡単に構築することができます。この記事ではそのようなパイプラインの例を紹介し、操作が失敗したときに発生する
繊細な事柄にハイライトを当て、また失敗に綺麗に対応するテクニックを紹介します。

## パイプラインとはなにか
Goにおいて、パイプラインの厳密な定義はありません。パイプラインは数ある並行プログラミングの種類の一つに過ぎません。
正式な定義ではないですが、パイプラインとはチャンネルによって接続された一連の _ステージ_ を挿します。
そこでは、各ステージでは同じ関数を実行するゴルーチンのまとまりになっています。
各ステージではゴルーチンは次の役割を果たします。

* _上流_ から _流入_ チャンネル経由で値を受け取る
* そのデータに対してある関数を実行し、通常は新しい値を生成する
* _下流_ へ _流出_ チャンネル経由で値を送信する

各ステージでは、任意の数の流入と流出のチャンネルを持っています。ただし最初と最後のステージは例外で、
それぞれ流出と流入のチャンネルのみが存在します。最初のステージは時々 _ソース_ あるいは _プロデューサー_ と呼ばれ、
最後のステージは _シンク_ あるいは _コンシューマー_ と呼ばれます。

パイプラインの考え方とそのテクニックを説明するために単純なパイプラインの例から始めてみましょう。
あとでより現実的な例を紹介します。

## 数字を平方する
3つのステージからなるパイプラインを考えてみましょう。

最初のステージ `gen` は整数のリストからチャンネルに変換する関数です。このチャンネルがリスト内の整数を出すことになります。
`gen` 関数は整数をチャンネルに送信するゴルーチンを起動し、すべての値が送信されたらチャンネルを閉じます。

```
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        for _, n := range nums {
            out <- n
        }
        close(out)
    }()
    return out
}
```

2番めのステージは `sq` で、チャンネルから整数を受信して、受信した整数それぞれの平方を出すチャンネルを返します。
流入のチャンネルが閉じて、すべての値を下流に送った後に、流出のチャンネルを閉じます。

```
func sq(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        for n := range in {
            out <- n * n
        }
        close(out)
    }()
    return out
}
```

`main` 関数はパイプラインを設定し、最後のステージを実行します。2番めのステージから値を受信し、チャンネルが閉じるまで、
それぞれを出力します。

```
func main() {
    // パイプラインを設定する。
    c := gen(2, 3)
    out := sq(c)

    // 出力を消費する。
    fmt.Println(<-out) // 4
    fmt.Println(<-out) // 9
}
```

`sq` では流入と流出のチャンネルでそれぞれ同じ型なので、 `sq` を何回でも繰り返すことができます。
また `main` を他のステージと同様にrangeを使ったループに書き換えることもできます。

```
func main() {
    // パイプラインを設定して出力を消費する。
    for n := range sq(sq(gen(2, 3))) {
        fmt.Println(n) // 16 then 81
    }
}
```

## ファンアウト、ファンイン
チャンネルが閉じるまで複数の関数が1つのチャンネルを読み込むことが可能です。
これは _ファンアウト_ と呼ばれます。この構成はCPU使用率とI/Oを平行に使うために
ワーカー群に仕事を分配する方法を提供しています。

1つの関数は入力チャンネルを多重化して1つのチャンネルに流し込むことで、すべての入力が閉じるまで
複数の入力から読み込み処理をすることができて、流し込む先のチャンネルはすべての入力が閉じると閉じられます。
これを _ファンイン_ と呼びます。

先ほどのパイプラインを2つの `sq` のインスタンスを実行するように変更し、それぞれが同一の
入力チャンネルから読み込むようにできます。ここで新しい関数 `merge` を用意して結果をファンインします。

```
func main() {
    in := gen(2, 3)

    // sq の仕事を同一のチャンネル in から読み込む2つのゴルーチンに分配します。
    c1 := sq(in)
    c2 := sq(in)

    // c1 と c2 の結果をマージしたものを消費します。
    for n := range merge(c1, c2) {
        fmt.Println(n) // 4 then 9, or 9 then 4
    }
}
```

`merge` 関数は、流入チャンネルそれぞれに対してゴルーチンを起動して、値を唯一の流出チャンネルに
コピーすることで、チャンネルのリストを1つのチャンネルに変換します。すべての `output` ゴルーチンが
起動したら、 `merge` は更にもう一つゴルーチンを起動して、そのチャンネルへの送信がすべて終わったら
流出チャンネルを閉じます。

閉じたチャンネルに送信するとパニックになるので、closeを呼ぶ前にすべての値が送信されていることを
確実にすることが大事です。 [sync.WaitGroup](http://golang.org/pkg/sync/#WaitGroup) 型はこのような
同期を用意する簡単な方法を提供しています。

```
func merge(cs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    // cs 内の各入力チャンネルに対して output ゴルーチンを起動。
    // output は c が閉じるまで c から out に値をコピーして、その後 wg.Done を呼び出す。
    output := func(c <-chan int) {
        for n := range c {
            out <- n
        }
        wg.Done()
    }
    wg.Add(len(cs))
    for _, c := range cs {
        go output(c)
    }

    // output ゴルーチンがすべて終了したら out を閉じるためのゴルーチンを起動する。
    // これは wg.Add が呼び出された後に起動しなければならない。
    go func() {
        wg.Wait()
        close(out)
    }()
    return out
}
```

## 欠落を止める
私たちのパイプライン関数にはパターンがあります。

* 送信が全て完了したら流出チャンネルを閉じるステージ
* チャンネルが閉じるまで流入チャンネルから値を受信し続けるステージ

このパターンは受信の各ステージを `range` のループで書くことができ、またすべての値が無事に下流に送信されたら
確実にすべてのゴルーチンが終了してくれます。

しかし実際のパイプラインでは、ステージで流入するすべての値を受信するとは限りません。
ときには設計がすべてを受信しないようにしていることがあります。受信するステージでは
処理のためにすべての値の中の一部だけが必要なことがあります。また、しばしば流入する値が
前のステージでの異常値を表している場合に終了することがあります。
どちらの場合でも、受信するステージでは残りの値を待つべきではないですし、前段のステージで
後段のステージで必要にならない値を生成するのを止めたいものです。

私たち例のパイプラインでは、ステージが流入する値のすべてを消費できなかった場合、
それらの値を送信しようとするゴルーチンはいつまでもブロックし続けます。

```
    // 出力からの最初の値を消費する
    out := merge(c1, c2)
    fmt.Println(<-out) // 4 か 9
    return
    // outから2番めの値を受け取ってないため
    // 出力用のゴルーチンは2番めの値を送信しようとしてとどまってしまいます
}
```

これがリソースリークです。ゴルーチンがメモリとランタイムの資源を消費して、ゴルーチンのスタック内の
ヒープの参照はデータがガベージコレクトされないようにします。ゴルーチンはガベージコレクトされません。
ゴルーチンは自分自身で終了しなければいけません。

パイプラインの下流のステージがすべての流入する値を受信できなかった場合にも上流のステージが終了するように
変更する必要があります。修正方法の一つとして、流出のチャンネルにバッファを持たせる方法があります。
バッファは決まった数の値を持つことができます。バッファ内に空きができ次第送信の操作が完了します。

```
c := make(chan int, 2) // バッファのサイズは 2
c <- 1  // ただちに成功
c <- 2  // ただちに成功
c <- 3  // 他のゴルーチンが <-c として 1 を受信するまでブロック
```

チャンネルを作成するときに送信される値の数がわかっている場合、バッファの確保によってコードを短くできます。
たとえば、 `gen` を整数のリストをバッファ付きのチャンネルにコピーするようにコードを書き換えて、
新しいゴルーチンを生成しないようにすることができます。

```
func gen(nums ...int) <-chan int {
    out := make(chan int, len(nums))
    for _, n := range nums {
        out <- n
    }
    close(out)
    return out
}
```

先ほどのパイプラインの話に戻ると、 `merge` によって返される流出チャンネルにバッファを追加することを考えてみましょう。

```
func merge(cs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int, 1) // 未読の入力に対して十分な領域
    // ... あとはさきほどと同じ ...
```

この変更でプログラム中でゴルーチンがブロックしてしまう件は修正されましたが、これは良くないコードです。
ここでバッファサイズを1にしているのは、 `merge` が受信する値の数と下流のステージで消費される値の数を知っているから
できることです。これは脆い設計です。 `gen` にさらに値を渡した場合、あるいは下流で読み取る値を減らした場合、
再びブロックするゴルーチンが発生してしまいます。

かわりに、下流のステージがこれ以上入力を受け付けないことを送信元に伝える方法を提供する必要があります。

## 明示的なキャンセル
`main` が `out` からの値をすべて受信せずに終了すると決めたとき、 `main` は上流のステージのゴルーチンに
送信しようとしている値を破棄するように伝えなければいけません。これは `done` というチャンネルに値を送ることで
実現しています。 `main` は潜在的にブロックする可能性がある2つの送信元があるので2つ値を送信します。

```
func main() {
    in := gen(2, 3)

    // in からともに値を読み取る2つのゴルーチンに sq の処理を分配します
    c1 := sq(in)
    c2 := sq(in)

    // 最初の値を出力から消費します
    done := make(chan struct{}, 2)
    out := merge(done, c1, c2)
    fmt.Println(<-out) // 4 or 9

    // まだ処理を続けている送信元に終了することを伝えます
    done <- struct{}{}
    done <- struct{}{}
}
```

送信するゴルーチンでは、送信の操作を `select` 文に置き換えて、 `out` への送信があった場合、もしくは `done`
から値を受信した場合に処理が進むようにします。 `done` の型は空の構造体です。その理由は、値は関係ないからです。
つまり、単純に `out` への送信を辞めるべきタイミングを示すイベントを受信するだけのものだからです。
`output` ゴルーチンは上流のステージがブロックされないように流入チャンネルの `c` に対してループを続けます。
（すぐ後で、このループが早めに終われるようにするかをお話します）

```
func merge(done <-chan struct{}, cs ...<-chan int) <-chan int {
    var wg sync.WaitGroup
    out := make(chan int)

    // output ゴルーチンを cs 内の各入力チャンネルに対して起動します。
    // output は c がチャンネルを閉じるまで、あるいは、doneから値を受け取るまで
    // 値をコピーし続け、その後 wg.Done を呼び出します。
    output := func(c <-chan int) {
        for n := range c {
            select {
            case out <- n:
            case <-done:
            }
        }
        wg.Done()
    }
    // ... あとはさきほどと同じ ...
```
