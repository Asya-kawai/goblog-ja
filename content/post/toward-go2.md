+++
date = "2017-07-13T15:35:46+09:00"
title = "Go2にむけて"
draft = false
tags = ["go2"]
+++

# Go 2にむけて
[Toward Go 2](https://blog.golang.org/toward-go2) by Russ Cox

## はじめに

（この文章は本日行われた Gophercon 2017 での私の発表の書き起こしで、Goコミュニティ全体にGo 2のための議論や計画をする中での支援を求めるものです。
動画が公開されたらこちらにリンクする予定です。）

Rob Pike、Robert Griesemer、そしてKen Thompsonが新しいプログラミング言語について数日議論を重ねた後、2007年9月25日にRobが「Go」という名前を提案しました。

![mail](./mail.png)

翌年、Ian Lance Taylorと私がチームに参加し、5人で2つのコンパイラと標準ライブラリを開発し、その成果が2009年11月10日の[オープンソースリリース](https://opensource.googleblog.com/2009/11/hey-ho-lets-go.html)となりました。

![tweet](./tweet.png)

それからの2年は、できたばかりのGoのオープンソースコミュニティの支援のもとに、大小様々な変更を伴う実験をしつつGoを洗練させ、その結果が2011年10月5日に提案された[Go 1のリリース計画](https://blog.golang.org/preview-of-go-version-1)となりました。

![go1-preview](./go1-preview.png)

さらにGoコミュニティからより多くの協力をうけ、Go 1のリリース計画を改定しつつ、それを元に実装を進め、最終的に2012年3月28日に[Go 1をリリース](https://blog.golang.org/go-version-1-is-released)しました。

![go1-release](./go1-release.png)

およそ5年の歳月をかけた、創造的で熱狂的な努力の最終成果が、Go 1のリリースという形となりました。その間、命名やアイデアのリストが、安定した本番環境で利用可能な言語として形付けられました。
またこの成果は、変化や仲間内での試行錯誤から安定性の明示的な変遷の結果でもあります。

Go 1への歳月のなかで、私たちはGoを変更し、皆のGoプログラムをほぼ毎週壊していました。私たちはそういった変更がGoの本番での利用を妨げるものになっていたことは承知していました。
本番環境では言語の変更に追従するために毎週変更することなどはできませんから。[Go 1のリリース宣言のブログポスト](https://blog.golang.org/go-version-1-is-released)にも書いているように、
Go 1のリリースの主要なモチベーションは、信頼できる製品やプロジェクトや出版物（ブログ、チュートリアル、カンファレンスでの発表、書籍）を作成する安定した基盤を提供し、それによってユーザーの製品がコンパイルし続けられ、何年も変更無しで実行し続けられるという信用を勝ち取ることでした。

Go 1がリリースされた後、私たちはGoが設計された本来の目的である、本番環境での利用に時間を費やす必要があることを認識していました。それから言語の変更そのものからあえて離れ、私たちのプロジェクトでのGoの利用や実装の改善へと注力する対象を移しました。私たちはGoをさまざまな新しいシステムにポートし、Goがより効率的に実行するようにパフォーマンスに致命的なあらゆる箇所を再実装しました。また、[競合条件検出ツール（race detector）](https://blog.golang.org/race-detector)といった新しい重要なツールも追加しました。

いま、私たちはGoを大規模の本番環境に耐える品質のシステムで使う経験を5年重ねてきました。私たちはどのような機能がそのような環境に適合し、またどのような機能がそうでないかの知見をためてきました。
いまこそ、Goの進化と成長の次なる一歩をすすめ、Goの未来を計画するときです。本日、ここにGoコミュニティのみなさん、このGopherConにいる方も、その動画を見ている方も、このGoブログを後日読んでいる方も、そのすべての方々に、私たちとともにGo 2の計画や実装を進める支援をお願いいたします。

## 目標

私たちがいまGoの目標として掲げているものは2007年当時のものと変わりありません。私たちはプログラマが2つのスケーラビリティを管理するにあたって、より効率的になってほしいと考えています。まず本番環境の規模、特にクラウドソフトウェアなどの多くのサーバーと通信するような並行システムの管理。そして開発の規模、特にモダンなオープンソース開発で例示されるような疎結合で多くのエンジニアが協力しあうような巨大なコードベースの管理です。

このようなスケーラビリティはどのような規模の会社でも関係してきます。たった5人のスタートアップ企業も他の企業から提供される巨大なクラウドベースのAPIサービスを利用するでしょうし、自社開発のものよりも多くのオープンソースのソフトウェアを使うことになるでしょう。
スタートアップ企業が必要とする本番環境の規模と開発環境の規模は、Googleが必要とするそれと何も変わりません。

Go 2に対する私たちの目標は、Goがスケールする際の致命的な点を修正することにあります。

（これらの目標に関しては、Rob Pikeが2012年に書いた記事の"[Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article)"や、私の2015年のGopherConの発表の"[Go, Open Source, Community](https://blog.golang.org/open-source)"を参照してください。）

## 制約

Goの目標は当初から何も変わっていませんが、Goが持つ制約は変わっています。最も重要な制約は、既存で利用されているGoの存在です。私たちは少なくとも[世界中に50万人のGo開発者がいる](https://research.swtch.com/gophercount)と見積もっています。つまり、少なくとも何百万ものGoのソースファイルが存在し、10億行のGoコードが存在するということです。
これらのコードを書いているプログラマやこういったソースコードがGoの成功を表しています。しかし、これらはまたGo 2への制約でもあるのです。

Go 2はこれらすべての開発者とともになければなりません。私たちはこうした開発者に、古い慣習を捨て、素晴らしいと感じられるときだけ新しい慣習を覚えて欲しいとお願いする必要があります。
たとえば、Go 1以前では `error` 型で実装されていたメソッドは `String` という名前でしたが、Go 1では `Error` という名前に変更しました。これは `error` 型と自分自身で書式化できる他の型とを区別するために行われました。
ある日、私は `error` 型を実装していて、何も考えずに `Error` メソッドでなく `String` メソッドを実装していました。これはもちろんコンパイルできませんでした。5年経った今でも完全には古い慣習を捨てきれていないのです。
このようなわかりやすい名前にするための変更はGo 1では必要でしたが、Go 2ではよっぽどの理由がない限り混乱の元になるでしょう。

またGo 2は既存のすべてのGo 1のソースコードとともになければなりません。私たちはGoのエコシステムを分断させてはなりません。Go 1で書かれたパッケージをインポートしているGo 2のパッケージ、あるいはその逆、といった混在したプログラムが複数年の移行期間の中で苦労することなく動作しなければなりません。
私たちはそれをどのように実現するかを見出さなければなりません。`go fix`のような自動化ツールがある部分それを担うでしょう。

混乱を最小限にするために、すべての変更は慎重な考察や計画そしてツールを必要とします。それは代わりに変更の大きさを制限するものでもあります。大きくても2つか3つであり、確実に5つ以上ではないでしょう。

より多くの自然言語で使われる識別子をサポートしたり、2進数リテラルを追加するといった細かなメンテナンス的な変更は勘定に入れていません。細かな変更も重要ではありますが、それらは正しく動作させるのは比較的簡単です。いまここで触れているのは、大きな変更の可能性、たとえばエラー処理の追加サポートやイミュータブルや読み込み専用の値の導入、何らかのジェネリクスの追加、あるいはまだ提案されていないより重要な変更を指しています。
これらの大きな変更のうち、2つか3つしか導入できません。慎重に選ぶ必要があります。

## プロセス

ここで重要な疑問が湧いてくるでしょう。Goを開発するプロセスはどのようなものなのか。

Goの初期の段階では、私たち5人しかいなかったので、隣り合ったガラスの仕切りがある共有ブース2つで働いていました。
みなで1つのオフィスに集まって、問題を議論して、すぐに机に戻ってその解決策を実装に落とすといったことが容易に可能でした。
RobとRobertのオフィスには小さなソファとホワイトボードがあり、誰かがそこに行ってホワイトボードに例を書き始める、ということがよくありました。例を書き終わるころには、他のみなが一区切りつけて、座って議論を始められるようになっている、というのがいつもの流れでした。
こういった形式張らないなやり方は、今日の世界的なGoコミュニティではスケールしないことは明らかでしょう。

Goがオープンソースとして公開された後の仕事の一部は、私たちの特に形式の決まっていなかったプロセスを、メーリングリスト、イシュートラッカー、50万人のGo開発者がいる世界により形式的な形に移行させることでした。しかし、私が知る限りこれまで明示的に私たちのプロセス全体を説明しませんでした。
意識的にそのことを考えていなかったのでしょう。しかし、振り返ってみると、次の図が、最初のプロトタイプを作ったころからの、私たちのGo開発における基本的な流れです。

![process](./process.png)

ステップ1では、Goを使用することで、これによりGoでの体験を重ねます。

ステップ2では、Goで解決が必要であろう問題を特定し、それを知らせ、他の人に説明し、書き下します。

ステップ3では、その問題に対する解決策を提案し、議論を重ね、議論を元に解決策を改訂します。

ステップ4では、その解決策を実装し、評価し、評価を元に改善していきます。

最後のステップ5では、その解決策をリリースし、言語自体やライブラリへの追加、もしくはみなが日々使うツールの形で提供します。

ある変更に関して同じ人がすべてのステップを行う必要はありません。事実、通常は多くの人々があらゆるステップで協力し合い、一つの問題に対して多くの解決策が提案されます。また、どのステップでも、あるアイデアに関して先のステップに進まないほうがいいとわかったら、前のステップに戻ります。

私たちのこのプロセス全体の流れを話したことはないと思うのですが、一部に関しては話したことがあります。
2012年にGo 1をリリースして、いまこそGoを使いはじめるタイミングで、言語自体の変更をやめるときだ、と言ったのがステップ1についての説明でした。
2015年にGoの変更提案プロセスを導入したときには、ステップ3、4、5について説明しました。
しかし、ステップ2に関しては詳細を話したことがなかったので、ここで説明しようと思います。

（Go 1の開発と言語仕様の変更を止める話は、Rob PikeとAndrew GerrandのOSCON 2012の発表である"[The Path to Go 1](https://blog.golang.org/the-path-to-go-1)"を参照してください。提案プロセスに関しては、Andrew GerrandのGopherCon 2015での発表の"[How Go was Made](https://www.youtube.com/watch?v=0ht89TxZZnk)"や[提案プロセスに関するドキュメント](https://golang.org/s/proposal)を参照してください。）


## 問題を説明する

![process2](./process2.png)

問題を説明するときには2つの段階があります。第一段階（簡単なほう）は問題がなにかを正確に述べる部分です。開発者はこの点においては十分優れています。
結局、私たちが書くテストは解決される問題を記述したもので、その言語ではコンピューターでさえ理解できるほど正確な記述になっているからです。
第二段階（最も難しい部分）は、それを解決し、解決策を保守する部分です。問題を正確に記述することと比較して、私たちは問題の重要性を説明することはあまりなく、そのことにはそこまで優れていません。コンピューターは「なぜこのテストケースは重要なのですか。これは問題を解決するために必要ですか。この問題を解決することは最重要事項ですか。」とは決して尋ねてきません。いずれそうなることはあるかもしれませんが、今日ではそうではありません。

2011年の古い例を見てみましょう。次の例は、Go 1を計画しているときに私が `os.Error` から `error.Value` への変更について書いたものです。
